1) 
#include <iostream>
using namespace std;

#define SIZE 5
int queueArr[SIZE], front = -1, rear = -1;

bool isFull() {
    return rear == SIZE - 1;
}

bool isEmpty() {
    return front == -1 || front > rear;
}

void enqueue(int x) {
    if (isFull()) {
        cout << "Queue is FULL!\n";
        return;
    }
    if (front == -1) front = 0;
    queueArr[++rear] = x;
    cout << x << " inserted.\n";
}

void dequeue() {
    if (isEmpty()) {
        cout << "Queue is EMPTY!\n";
        return;
    }
    cout << queueArr[front++] << " removed.\n";
}

void peek() {
    if (isEmpty())
        cout << "Queue EMPTY\n";
    else
        cout << "Front element: " << queueArr[front] << endl;
}

void display() {
    if (isEmpty()) {
        cout << "Queue EMPTY\n";
        return;
    }
    for (int i = front; i <= rear; i++)
        cout << queueArr[i] << " ";
    cout << endl;
}

int main() {
    int choice, value;
    
    while (true) {
        cout << "\n--- SIMPLE QUEUE MENU ---\n";
        cout << "1. Enqueue\n2. Dequeue\n3. Display\n4. Peek\n5. Exit\n";
        cin >> choice;

        switch (choice) {
            case 1: cout << "Enter value: "; cin >> value; enqueue(value); break;
            case 2: dequeue(); break;
            case 3: display(); break;
            case 4: peek(); break;
            case 5: return 0;
            default: cout << "Invalid Choice!\n";
        }
    }
}

2)
#include <iostream>
using namespace std;

#define SIZE 5
int cq[SIZE], frontCQ = -1, rearCQ = -1;

bool isFullCQ() {
    return (rearCQ + 1) % SIZE == frontCQ;
}

bool isEmptyCQ() {
    return frontCQ == -1;
}

void enqueueCQ(int x) {
    if (isFullCQ()) {
        cout << "Circular Queue FULL!\n";
        return;
    }
    if (frontCQ == -1) frontCQ = 0;
    rearCQ = (rearCQ + 1) % SIZE;
    cq[rearCQ] = x;
    cout << x << " inserted.\n";
}

void dequeueCQ() {
    if (isEmptyCQ()) {
        cout << "Circular Queue EMPTY!\n";
        return;
    }
    cout << cq[frontCQ] << " removed.\n";
    if (frontCQ == rearCQ) {
        frontCQ = rearCQ = -1;
    } else {
        frontCQ = (frontCQ + 1) % SIZE;
    }
}

void peekCQ() {
    if (isEmptyCQ())
        cout << "Queue EMPTY\n";
    else
        cout << "Front: " << cq[frontCQ] << endl;
}

void displayCQ() {
    if (isEmptyCQ()) {
        cout << "Queue EMPTY\n";
        return;
    }
    int i = frontCQ;
    while (true) {
        cout << cq[i] << " ";
        if (i == rearCQ) break;
        i = (i + 1) % SIZE;
    }
    cout << endl;
}

int main() {
    int ch, val;

    while (true) {
        cout << "\n--- CIRCULAR QUEUE MENU ---\n";
        cout << "1. Enqueue\n2. Dequeue\n3. Display\n4. Peek\n5. Exit\n";
        cin >> ch;

        switch(ch) {
            case 1: cout << "Enter value: "; cin >> val; enqueueCQ(val); break;
            case 2: dequeueCQ(); break;
            case 3: displayCQ(); break;
            case 4: peekCQ(); break;
            case 5: return 0;
            default: cout << "Invalid!\n";
        }
    }
}

3)

Input → 4 7 11 20 5 9
Output → 4 20 7 5 11 9

#include <iostream>
#include <queue>
using namespace std;

int main() {
    queue<int> q, firstHalf;
    int arr[] = {4, 7, 11, 20, 5, 9};

    for (int x : arr) q.push(x);

    int n = q.size() / 2;

    for (int i = 0; i < n; i++) {
        firstHalf.push(q.front());
        q.pop();
    }

    while (!firstHalf.empty()) {
        q.push(firstHalf.front()); firstHalf.pop();
        q.push(q.front()); q.pop();
    }

    while (!q.empty()) {
        cout << q.front() << " ";
        q.pop();
    }
}

4) 

Input → a a b c
Output → a -1 b b

#include <iostream>
#include <queue>
using namespace std;

int main() {
    string s = "aabc";
    queue<char> q;
    int freq[26] = {0};

    for (char c : s) {
        freq[c - 'a']++;
        q.push(c);

        while (!q.empty() && freq[q.front() - 'a'] > 1)
            q.pop();

        if (q.empty()) cout << "-1 ";
        else cout << q.front() << " ";
    }
}

 5) :
(A) Two Queues
#include <queue>
using namespace std;

class Stack2Q {
    queue<int> q1, q2;

public:
    void push(int x) {
        q2.push(x);
        while (!q1.empty()) {
            q2.push(q1.front());
            q1.pop();
        }
        swap(q1, q2);
    }

    void pop() {
        if (!q1.empty()) q1.pop();
    }

    int top() {
        return q1.front();
    }

    bool empty() {
        return q1.empty();
    }
};

(B) One Queue
#include <queue>
using namespace std;

class Stack1Q {
    queue<int> q;

public:
    void push(int x) {
        q.push(x);
        for (int i = 0; i < q.size() - 1; i++) {
            q.push(q.front());
            q.pop();
        }
    }

    void pop() {
        q.pop();
    }

    int top() {
        return q.front();
    }

    bool empty() {
        return q.empty();
    }
};
