

#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>
using namespace std;

// ---------------------- BFS ----------------------
void BFS(int start, vector<vector<int>>& adj, int n) {
    vector<bool> visited(n, false);
    queue<int> q;

    visited[start] = true;
    q.push(start);

    cout << "BFS: ";
    while (!q.empty()) {
        int node = q.front();
        q.pop();
        cout << node << " ";

        for (int x : adj[node]) {
            if (!visited[x]) {
                visited[x] = true;
                q.push(x);
            }
        }
    }
    cout << endl;
}

// ---------------------- DFS ----------------------
void DFSUtil(int node, vector<vector<int>>& adj, vector<bool>& visited) {
    visited[node] = true;
    cout << node << " ";

    for (int x : adj[node])
        if (!visited[x])
            DFSUtil(x, adj, visited);
}

void DFS(int start, vector<vector<int>>& adj, int n) {
    vector<bool> visited(n, false);
    cout << "DFS: ";
    DFSUtil(start, adj, visited);
    cout << endl;
}

// ---------------------- KRUSKAL'S ALGORITHM ----------------------
struct Edge {
    int u, v, w;
};

int findParent(int node, vector<int>& parent) {
    if (parent[node] == node) return node;
    return parent[node] = findParent(parent[node], parent);
}

void Kruskal(int n, vector<Edge>& edges) {
    sort(edges.begin(), edges.end(), [](Edge a, Edge b) { return a.w < b.w; });

    vector<int> parent(n);
    for (int i = 0; i < n; i++) parent[i] = i;

    cout << "\nKruskal MST:\n";
    int cost = 0;

    for (auto e : edges) {
        int pu = findParent(e.u, parent);
        int pv = findParent(e.v, parent);

        if (pu != pv) {
            cout << e.u << " - " << e.v << " : " << e.w << endl;
            cost += e.w;
            parent[pu] = pv;
        }
    }
    cout << "Total Weight: " << cost << endl;
}

// ---------------------- PRIM'S ALGORITHM ----------------------
void Prim(int n, vector<vector<pair<int, int>>>& graph) {
    vector<bool> visited(n, false);
    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;

    pq.push({0, 0});
    int cost = 0;

    cout << "\nPrim MST:\n";
    while (!pq.empty()) {
        auto [w, node] = pq.top();
        pq.pop();

        if (visited[node]) continue;
        
        visited[node] = true;
        cost += w;

        cout << "Pick Node " << node << " with cost " << w << endl;

        for (auto nxt : graph[node])
            if (!visited[nxt.first])
                pq.push({nxt.second, nxt.first});
    }

    cout << "Total Weight: " << cost << endl;
}

// ---------------------- DIJKSTRA'S ALGORITHM ----------------------
void Dijkstra(int start, int n, vector<vector<pair<int, int>>>& graph) {
    vector<int> dist(n, 1e9);
    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;

    dist[start] = 0;
    pq.push({0, start});

    while (!pq.empty()) {
        auto [d, node] = pq.top();
        pq.pop();

        for (auto nxt : graph[node]) {
            int v = nxt.first, w = nxt.second;
            if (dist[node] + w < dist[v]) {
                dist[v] = dist[node] + w;
                pq.push({dist[v], v});
            }
        }
    }

    cout << "\nDijkstra Shortest Distances:\n";
    for (int i = 0; i < n; i++)
        cout << start << " -> " << i << " = " << dist[i] << endl;
}

// ---------------------- MAIN FUNCTION ----------------------

int main() {
    int n, e;
    cout << "Enter number of vertices: ";
    cin >> n;
    cout << "Enter number of edges: ";
    cin >> e;

    vector<vector<int>> adj(n);
    vector<Edge> edges;
    vector<vector<pair<int,int>>> weighted(n);

    cout << "\nEnter edges (u v w):\n";
    for (int i = 0; i < e; i++) {
        int u, v, w;
        cin >> u >> v >> w;

        adj[u].push_back(v);
        adj[v].push_back(u);

        edges.push_back({u, v, w});

        weighted[u].push_back({v, w});
        weighted[v].push_back({u, w});
    }

    BFS(0, adj, n);
    DFS(0, adj, n);
    Kruskal(n, edges);
    Prim(n, weighted);
    Dijkstra(0, n, weighted);

    return 0;
}
